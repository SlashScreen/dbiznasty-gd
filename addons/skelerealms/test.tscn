[gd_scene load_steps=13 format=3 uid="uid://bua7kr46ab5p5"]

[ext_resource type="Script" path="res://addons/skelerealms/scripts/Entities/entity_manager.gd" id="1_cpofd"]
[ext_resource type="Script" path="res://addons/skelerealms/scripts/Components/player_component.gd" id="3_73cda"]
[ext_resource type="Script" path="res://addons/skelerealms/scripts/Components/inventory_component.gd" id="3_apdp0"]
[ext_resource type="Script" path="res://addons/skelerealms/scripts/Components/teleport_component.gd" id="4_f65ms"]
[ext_resource type="Script" path="res://addons/skelerealms/scripts/Components/puppet_spawner_component.gd" id="5_g8w2r"]
[ext_resource type="PackedScene" uid="uid://c1bwgrswdshee" path="res://player.tscn" id="6_5ybbi"]
[ext_resource type="Script" path="res://addons/skelerealms/scripts/System/world_loader.gd" id="7_wp4t3"]
[ext_resource type="PackedScene" uid="uid://d3xvrivp3iwfb" path="res://Worlds/test world 1.tscn" id="8_7k0r4"]
[ext_resource type="PackedScene" uid="uid://cb36xhkpqr1j4" path="res://ui scripts/hud.tscn" id="10_r80ts"]
[ext_resource type="PackedScene" uid="uid://dl8vo4jn7mx63" path="res://ui scripts/menu.tscn" id="11_f8v2q"]

[sub_resource type="GDScript" id="GDScript_e74se"]
script/source = "class_name Entity 
extends Node
## An entity for the pseudo-ecs. Contains [EntityComponent]s.
## These allow constructs such as NPCs and Items to persist even when not in the scene.


## The world this entity is in.
@export var world: String
## Position within the world it's in.
@export var position:Vector3
## Rotation of this Enitiy.
@export var rotation:Quaternion
## An internal timer of how long this entity has gone without being modified or referenced. 
## One it's beyond a certain point, the [EntityManager] will mark it for cleanup after a save.
var stale_timer:float


## Whether this entity is in the scene or not.
var in_scene: bool: 
	get:
		return in_scene
	set(val):
		if in_scene && !val: # if was in scene and now not
			left_scene.emit()
		if !in_scene && val: # if was not in scene and now is
			entered_scene.emit()
		in_scene = val


## Emitted when an entity enters a scene.
signal left_scene
## Emitted when an entity leaves a scene.
signal entered_scene
## This signal is emitted when all components have been added once [EntityManager.add_entity] is called.
## Await this when you want to connect with other nodes.
signal instantiated


func _init(res:InstanceData = null) -> void:
	if not res:
		return
	
	var new_nodes = res.get_archetype_components() # Get the entity components
	
	name = res.ref_id # set its name to the instance refID
	world = res.world
	position = res.position
	
	for n in new_nodes: # add all components to entity
		add_child(n)
		n.owner = self
	
	# call entity ready
	instantiated.emit()
	for c in get_children():
		c._entity_ready()


func _ready():
	add_to_group(\"savegame_entity\")


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta):
	_should_be_in_scene()
	# If we aren't in the scene, start counting up. Otherwise, we are still in the scene with the player and shouldn't depsawn.
	if not in_scene:
		stale_timer += delta
	else:
		stale_timer = 0


## Determine that this entity should be in scene
func _should_be_in_scene():
	# if not in correct world
	if GameInfo.world != world:
		in_scene = false
		return
	# if we are outside of actor fade distance
	if position.distance_squared_to(GameInfo.active_camera.position) > ProjectSettings.get_setting(\"skelerealms/actor_fade_distance\") ** 2: 
		in_scene = false
		return
	in_scene = true


func _on_set_position(p:Vector3):
	position = p


func _on_set_rotation(q:Quaternion) -> void:
	rotation = q


## Gets a component by the string name. 
## Example: [codeblock]
## (e.get_component(\"NPCComponent\").unwrap() as NPCComponent).kill()
## [/codeblock]
func get_component(type:String) -> Option:
	var n = get_node_or_null(type)
	return Option.from(n)


## Whether it has a component type or not. Useful for checking the capabilities of an entity.
func has_component(type:String) -> bool:
	var x = get_component(type)
	return x.some()


func save() -> Dictionary: 
	var data:Dictionary = {
		\"entity_data\": {
			\"world\" = world,
			\"position\" = position,
		}
	}
	for c in get_children().filter(func(x:EntityComponent): return x.dirty): # filter to get dirty acomponents
		data[\"components\"][c.name] = ((c as EntityComponent).save())
	return data


func load_data(data:Dictionary):
	world = data[\"entity_data\"][\"world\"]
	position = JSON.parse_string(data[\"entity_data\"][\"position\"])
	
	# loop through all saved components and call load
	for d in data[\"components\"]:
		(get_node(d) as EntityComponent).load_data(data[d])
	pass


func reset_stale_timer():
	stale_timer = 0


func broadcast_message(msg:String) -> void:
	for c in get_children():
		if c.has_method(msg):
			c.call(msg)


func dialogue_command(command:String, args:Array) -> void:
	for c in get_children():
		c._try_dialogue_command(command, args)
"

[sub_resource type="GDScript" id="GDScript_3kmd4"]
script/source = "class_name CovensComponent
extends EntityComponent
## Allows an Entity to be part of a [Coven].
## Covens in this context are analagous to Bethesda games' Factions- groups of NPCs that behave in a similar way.
## Coven membership is also reflected in groups that the entity is in.


## IDs of covens this entity is a member of.
## This dictionary is of type StringName:Int, where key is the coven, and int is the rank of this member.
@export var covens:Dictionary


func _init(coven_list:Array[CovenRankData] = []) -> void:
	name = \"CovensComponent\"
	if coven_list.is_empty():
		return
	# Load rank info
	for crd in coven_list:
		print(\"Adding to coven %s\" % crd.coven.coven_id)
		covens[crd.coven.coven_id] = crd.rank


func _ready():
	super._ready()
	# Add corresponding covens.
	for c in covens:
		parent_entity.add_to_group(c)


## Add this entity to a coven.
func add_to_coven(coven:StringName, rank:int = 1):
	covens[coven] = 1
	parent_entity.add_to_group(coven)


## Remove this entity from the coven.
func remove_from_coven(coven:StringName):
	covens.erase(coven)
	parent_entity.remove_from_group(coven)


## Whether the entity is in a coven or not.
func is_in_coven(coven:StringName) -> bool:
	return covens.has(coven)


## Get this entity's rank in a coven. Returns 0 if they aren't in the coven.
func get_coven_rank(coven:StringName) -> int:
	return covens[coven] if covens.has(coven) else 0
"

[node name="Game" type="Node3D"]

[node name="EntityManager" type="Node" parent="."]
unique_name_in_owner = true
process_priority = -1
script = ExtResource("1_cpofd")

[node name="Player" type="Node" parent="EntityManager" groups=["savegame_entity"]]
script = SubResource("GDScript_e74se")
world = "test world 1"

[node name="CovensComponent" type="Node" parent="EntityManager/Player"]
script = SubResource("GDScript_3kmd4")
covens = {
"PlayerCoven": 0
}

[node name="InventoryComponent" type="Node" parent="EntityManager/Player"]
script = ExtResource("3_apdp0")

[node name="PlayerComponent" type="Node" parent="EntityManager/Player"]
script = ExtResource("3_73cda")

[node name="TeleportComponent" type="Node" parent="EntityManager/Player"]
script = ExtResource("4_f65ms")

[node name="PuppetSpawnerComponent" type="Node" parent="EntityManager/Player"]
script = ExtResource("5_g8w2r")

[node name="Player" parent="EntityManager/Player/PuppetSpawnerComponent" instance=ExtResource("6_5ybbi")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 2.42557)

[node name="WorldLoader" type="Node" parent="."]
unique_name_in_owner = true
script = ExtResource("7_wp4t3")

[node name="test world 1" parent="WorldLoader" instance=ExtResource("8_7k0r4")]

[node name="HUD" parent="." instance=ExtResource("10_r80ts")]

[node name="Menu" parent="." instance=ExtResource("11_f8v2q")]
